/*
Copyright Â© 2023 Ross Video Limited, All Rights Reserved.

Licensed under the Creative Commons Attribution NoDerivatives 4.0
International Licensing (CC-BY-ND-4.0);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at:

https://creativecommons.org/licenses/by-nd/4.0/

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

syntax = "proto3";

package catena;

import "constraint.proto";
import "param.proto";
import "menu.proto";
import "language.proto";
import "externalobject.proto";

option java_multiple_files = true;
option java_package = "catena.core.device";
option java_outer_classname = "DeviceProtos";

option optimize_for = CODE_SIZE;

/* Some parameters share sub-param descriptors and/or constraints.
 * They can be selected by reference into the Types message which
 * contains a map of each. The motivation is to improve the efficiency
 * of communications and memory footprint by avoiding the duplication
 * of commonly occurring constraints and parameter types.
 */
message Types {
  ConstraintDescriptors constraints = 1;
  map<string, Param> params = 2;
}

/* Device model for Catena compatible devices. */
message Device {
  // ID for the device, locally unique within the Catena connection.
  uint32 slot = 1;

  // How much of the device model to deliver.
  enum DetailLevel {
    FULL = 0;
    SUBSCRIPTIONS = 1;
    MINIMAL = 2;
    COMMANDS = 3;
    NONE = 4;
  }
  DetailLevel detail_level = 2;

  // Whether multi-set message is supported
  bool multi_set_enabled = 3;

  // Whether subscriptions are supported
  bool subscriptions = 4;

  // Device's timeout, in ms
  uint32 timeout = 5;

  // The device's shared constraints. A map of Constraint, keyed by their object ids (OIDs).
  map<string, Constraint> constraints = 6;

  // The device's parameters. A map of Param, keyed by their object ids (OIDs).
  map<string, Param> params = 7;

  // The device's default editor UI definition and access scope definitions
  MenuGroups menu_groups = 8;

  // The device's available commands, keyed by their object ids (OIDs).
  map<string, Param> commands = 9;

  // The devices language packs
  LanguagePacks language_packs = 10;

  // The device's access scopes, a list of mutually unique strings
  repeated string access_scopes = 11;

  // The default scope, index into access_scopes to indicate which of them is the default.
  uint32 default_scope = 12;
}

/* The Device model broken into smaller pieces.
 * Design intent is to allow very large Device Models to be delivered
 to clients as a stream of DeviceComponents.
 */
message DeviceComponent {

  /* A parameter or sub-parameter, or sub-sub-parameter, or ...
   *
   * These can be arbitrarily nested so a JSON pointer (RFC 6901) is used to
   * locate the component within the data model.
   * This is to allow large parameter trees to be broken into smaller
   * components.
   *
   * The json_pointer is relative to device["params"].
   * Let's see how this could be arranged for an audio processing device
   * which has a monitor output mix that has gain and eq controls.
   *
   * monitor - top level object id. The json_pointer is an object id in this
   * case. The whole multi-level parameter descriptor would form the body
   * of the message.
   *
   * monitor/eq, monitor/level - sub-params of the top-level monitor
   * parameter. The json_pointer is a cascade of object IDs.
   * Only the selected sub-param occupies the message body. Note that the eq
   * param is likely an array of 4 objects. Without an index in the
   * json_pointer, the whole array forms the body of the message.
   *
   * monitor/eq/1/f, monitor/eq/1/q, monitor/eq/1/gain sub-sub params of
   * eq 2 in the monitor output audio processing.
   * It's likely not practical to use messages this small to report device
   * models, but this illustrates how it could be done if desirable.
   */
  message ComponentParam {
    string oid = 1;
    Param param = 2;
  }

   /* A menu.
    * Note that menus are grouped into menu groups. They are uniquely identified
    * by the json_pointer field which is relative to the Device's top-level
    * menu-groups object thus: menu-group-name/menu-name.
    * example: status/vendor_info
    */
  message ComponentMenu {
    string oid = 1;
    Menu menu = 2;
  }

   /* A constraint descriptor.
    * The oid is relative to the "constraints" child of the device's top-level
    * "types" object.
    */
  message ComponentConstraint {
    string oid = 1;
    Constraint constraint = 2;
  }

  /* A command descriptor.
   * Defines a command to be mapped to device.commands.oid
   */
  message ComponentCommand {
    string oid = 1;
    Param param = 2;
  }

  /* A language pack. */
  message ComponentLanguagePack {
    string language = 1; // Language string is the language code that identifies the language e.g. en-uk
    LanguagePack language_pack = 2;
  }

  /* Small device models can be sent as a whole.
   * Larger ones should be broken into a stream of smaller components.
   */
  oneof kind {
    Device device = 2;
    ComponentParam param = 3;
    ComponentConstraint shared_constraint = 4;
    ComponentMenu menu = 5;
    ComponentCommand command = 6;
    ComponentLanguagePack language_pack = 7;
  }
}

message RemoveComponents {
  message RemoveParams {
    repeated string oids = 1;
  }

   /* A menu.
    * Note that menus are grouped into menu groups. They are uniquely identified
    * by the json_pointer field which is relative to the Device's top-level
    * menu-groups object thus: menu-group-name/menu-name.
    * example: status/vendor_info
    */
  message RemoveMenus {
    repeated string oids = 1;
  }

   /* A constraint descriptor.
    * The oid is relative to the "constraints" child of the device's top-level
    * "types" object.
    */
  message RemoveConstraints {
    repeated string oids = 1;
  }

  /* A command descriptor.
   * Defines a command to be mapped to device.commands.oid
   */
  message RemoveCommands {
    repeated string oids = 1;
  }

  /* A language pack. */
  message RemoveLanguagePacks {
    repeated string languages = 1; // Language string is the language code that identifies the language e.g. en-uk
  }

	oneof kind {
    RemoveParams param = 3;
    RemoveConstraints shared_constraint = 4;
    RemoveMenus menu = 5;
    RemoveCommands command = 6;
    RemoveLanguagePacks language_pack = 7;
  }
}

message DeviceRequestPayload {
  uint32 slot = 1;                     // The slot id, must be included
  string language = 2;                 // Optionally specify the language for the response
  Device.DetailLevel detail_level = 3; // Optionally specify the detail level for the response
  repeated string subscribed_oids = 4; // Optionally specify a subscription list for the device (see UpdateSubscriptionsPayload)
}

/* Initial handshake between client and device. */
message ConnectPayload {
  string language = 1;
  Device.DetailLevel detail_level = 2;
  string user_agent = 3;               // Description of the client type and version
  bool force_connection = 4;           // True to request access if connection had been previously refused
  // authn / authz should be handled by gRPC metadata
}

message TrapMessage {
	string trap_type = 1;
	repeated string trap_data = 2;
}

/* Messages that the device can push to the client. */
message PushUpdates {
  message PushExternalObject {
    string oid = 1;
	ExternalObjectPayload external_object = 2;
  }

  message PushValue {
    string oid = 1;
	Value value = 2;
  }

  uint32 slot = 1;
  oneof kind {
    PushValue value = 2; // e.g. audio meters
    DeviceComponent device_component = 3;
    Exception refused = 4;
    string invalidated_external_object_id = 5;
    TrapMessage trap_message = 6;
    bool invalidate_device_model = 7;
    PushExternalObject external_object = 8;
    RemoveComponents remove_device_components = 9;
  }
}
