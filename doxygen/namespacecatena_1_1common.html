<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cpp-v0.0.10-5: catena::common Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="doxylogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">cpp-v0.0.10-5
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacecatena_1_1common.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">catena::common Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Functionality that can be shared between the different connection management types.  
<a href="namespacecatena_1_1common.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1Authorizer.html">Authorizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling authorization information.  <a href="classcatena_1_1common_1_1Authorizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcatena_1_1common_1_1CommandTag.html">CommandTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classcatena_1_1common_1_1IParam.html" title="IParam is the interface for business logic and connection logic to interact with parameters.">IParam</a> used to improve readability.  <a href="structcatena_1_1common_1_1CommandTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1Connect.html">Connect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual class for <a class="el" href="classcatena_1_1common_1_1Connect.html" title="Pure virtual class for Connect RPCs. Contains functions for updating the response message with parame...">Connect</a> RPCs. Contains functions for updating the response message with parameter values. Can only be inherited.  <a href="classcatena_1_1common_1_1Connect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcatena_1_1common_1_1ConstraintTag.html">ConstraintTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classcatena_1_1common_1_1IConstraint.html" title="Interface for constraints.">IConstraint</a> used to improve readability.  <a href="structcatena_1_1common_1_1ConstraintTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1Device.html">Device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the <a class="el" href="classcatena_1_1common_1_1Device.html" title="Implements the Device interface defined in the protobuf.">Device</a> interface defined in the protobuf.  <a href="classcatena_1_1common_1_1Device.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcatena_1_1common_1_1EmptyValue.html">EmptyValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcatena_1_1common_1_1EmptyValue.html" title="EmptyValue is used for commands that do not have a value.">EmptyValue</a> is used for commands that do not have a value.  <a href="structcatena_1_1common_1_1EmptyValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcatena_1_1common_1_1FakeLock.html">FakeLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fake lock for use in recursive function calls.  <a href="structcatena_1_1common_1_1FakeLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcatena_1_1common_1_1FieldInfo.html">FieldInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcatena_1_1common_1_1FieldInfo.html" title="FieldInfo pairs the name of a field with the type information needed to access it.">FieldInfo</a> pairs the name of a field with the type information needed to access it.  <a href="structcatena_1_1common_1_1FieldInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1IConnect.html">IConnect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class for <a class="el" href="classcatena_1_1common_1_1Connect.html" title="Pure virtual class for Connect RPCs. Contains functions for updating the response message with parame...">Connect</a> RPCs.  <a href="classcatena_1_1common_1_1IConnect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1IConstraint.html">IConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for constraints.  <a href="classcatena_1_1common_1_1IConstraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1IDevice.html">IDevice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class for <a class="el" href="classcatena_1_1common_1_1Device.html" title="Implements the Device interface defined in the protobuf.">Device</a>.  <a href="classcatena_1_1common_1_1IDevice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1ILanguagePack.html">ILanguagePack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for Language Packs.  <a href="classcatena_1_1common_1_1ILanguagePack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1IMenu.html">IMenu</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for Menus.  <a href="classcatena_1_1common_1_1IMenu.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1IMenuGroup.html">IMenuGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for <a class="el" href="classcatena_1_1common_1_1Menu.html" title="A device menu.">Menu</a> Group.  <a href="classcatena_1_1common_1_1IMenuGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1IParam.html">IParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcatena_1_1common_1_1IParam.html" title="IParam is the interface for business logic and connection logic to interact with parameters.">IParam</a> is the interface for business logic and connection logic to interact with parameters.  <a href="classcatena_1_1common_1_1IParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1IParamVisitor.html">IParamVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for parameter visitors.  <a href="classcatena_1_1common_1_1IParamVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1IPolyglotText.html">IPolyglotText</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for managing multilingual text with support for serialization to protocol buffers.  <a href="classcatena_1_1common_1_1IPolyglotText.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1ISubscriptionManager.html">ISubscriptionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for managing parameter subscriptions in Catena.  <a href="classcatena_1_1common_1_1ISubscriptionManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1LanguagePack.html">LanguagePack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a language pack  <a href="classcatena_1_1common_1_1LanguagePack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcatena_1_1common_1_1LanguagePackTag.html">LanguagePackTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classcatena_1_1common_1_1ILanguagePack.html" title="Interface for Language Packs.">ILanguagePack</a> used to improve readability.  <a href="structcatena_1_1common_1_1LanguagePackTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1Menu.html">Menu</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A device menu.  <a href="classcatena_1_1common_1_1Menu.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1MenuGroup.html">MenuGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Group of device menus.  <a href="classcatena_1_1common_1_1MenuGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcatena_1_1common_1_1MenuGroupTag.html">MenuGroupTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classcatena_1_1common_1_1IMenuGroup.html" title="Interface for Menu Group.">IMenuGroup</a> used to improve readability.  <a href="structcatena_1_1common_1_1MenuGroupTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcatena_1_1common_1_1MenuTag.html">MenuTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classcatena_1_1common_1_1IMenu.html" title="Interface for Menus.">IMenu</a> used to improve readability.  <a href="structcatena_1_1common_1_1MenuTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1NamedChoiceConstraint.html">NamedChoiceConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Named choice constraint, ensures a value is within a named choice.  <a href="classcatena_1_1common_1_1NamedChoiceConstraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1ParamDescriptor.html">ParamDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcatena_1_1common_1_1ParamDescriptor.html" title="ParamDescriptor provides information about a parameter.">ParamDescriptor</a> provides information about a parameter.  <a href="classcatena_1_1common_1_1ParamDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcatena_1_1common_1_1ParamTag.html">ParamTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classcatena_1_1common_1_1IParam.html" title="IParam is the interface for business logic and connection logic to interact with parameters.">IParam</a> used to improve readability.  <a href="structcatena_1_1common_1_1ParamTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1ParamVisitor.html">ParamVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete implementation of parameter visitor.  <a href="classcatena_1_1common_1_1ParamVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1ParamWithValue.html">ParamWithValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcatena_1_1common_1_1ParamWithValue.html" title="ParamWithValue is a class that implements the IParam interface for each param type in the device mode...">ParamWithValue</a> is a class that implements the <a class="el" href="classcatena_1_1common_1_1IParam.html" title="IParam is the interface for business logic and connection logic to interact with parameters.">IParam</a> interface for each param type in the device model.  <a href="classcatena_1_1common_1_1ParamWithValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1Path.html">Path</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts json pointers to items within the data model to a path of "segments" that can be iterated over.  <a href="classcatena_1_1common_1_1Path.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1PicklistConstraint.html">PicklistConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Picklist constraint, ensures a value is in a list of strings.  <a href="classcatena_1_1common_1_1PicklistConstraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1PolyglotText.html">PolyglotText</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of multilingual text handling with serialization support.  <a href="classcatena_1_1common_1_1PolyglotText.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1RangeConstraint.html">RangeConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range constraint, ensures a value is within a range.  <a href="classcatena_1_1common_1_1RangeConstraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcatena_1_1common_1_1StructInfo.html">StructInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcatena_1_1common_1_1StructInfo.html" title="StructInfo is specialized at compile time to provide type information about a struct.">StructInfo</a> is specialized at compile time to provide type information about a struct.  <a href="structcatena_1_1common_1_1StructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcatena_1_1common_1_1SubscriptionManager.html">SubscriptionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing parameter subscriptions in Catena.  <a href="classcatena_1_1common_1_1SubscriptionManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptcatena_1_1common_1_1CatenaStruct.html">CatenaStruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CatenaStruct concept checks that a type is a struct generated by the Catena code generator. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptcatena_1_1common_1_1CatenaStructArray.html">CatenaStructArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CatenaStructArray concept checks that a type is a vector of structs that meet the CatenaStruct concept. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptcatena_1_1common_1_1IsVariantArray.html">IsVariantArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IsVariantArray concept checks that a type is a vector of variants. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a225684244a1b6d89745e3850d8b93759" id="r_a225684244a1b6d89745e3850d8b93759"><td class="memItemLeft" align="right" valign="top"><a id="a225684244a1b6d89745e3850d8b93759" name="a225684244a1b6d89745e3850d8b93759"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Scopes</b> = <a class="el" href="classcatena_1_1patterns_1_1EnumDecorator.html">patterns::EnumDecorator</a>&lt; <a class="el" href="namespacecatena_1_1common.html#a52e17ef3ce00a51e608afb060211e3a8">common::Scopes_e</a> &gt;</td></tr>
<tr class="separator:a225684244a1b6d89745e3850d8b93759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505c00f6adb69c8e6d1e3ade6f2ff4d5" id="r_a505c00f6adb69c8e6d1e3ade6f2ff4d5"><td class="memItemLeft" align="right" valign="top"><a id="a505c00f6adb69c8e6d1e3ade6f2ff4d5" name="a505c00f6adb69c8e6d1e3ade6f2ff4d5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DetailLevel</b> = <a class="el" href="classcatena_1_1patterns_1_1EnumDecorator.html">patterns::EnumDecorator</a>&lt; catena::Device_DetailLevel &gt;</td></tr>
<tr class="separator:a505c00f6adb69c8e6d1e3ade6f2ff4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9d21b85f8c84cfd561ba53e9418083" id="r_aed9d21b85f8c84cfd561ba53e9418083"><td class="memTemplParams" colspan="2"><a id="aed9d21b85f8c84cfd561ba53e9418083" name="aed9d21b85f8c84cfd561ba53e9418083"></a>
template&lt;typename TAG &gt; </td></tr>
<tr class="memitem:aed9d21b85f8c84cfd561ba53e9418083"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddItem</b> = std::function&lt; void(const std::string &amp;key, typename TAG::type *item)&gt;</td></tr>
<tr class="separator:aed9d21b85f8c84cfd561ba53e9418083"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a52e17ef3ce00a51e608afb060211e3a8" id="r_a52e17ef3ce00a51e608afb060211e3a8"><td class="memItemLeft" align="right" valign="top"><a id="a52e17ef3ce00a51e608afb060211e3a8" name="a52e17ef3ce00a51e608afb060211e3a8"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecatena_1_1common.html#a52e17ef3ce00a51e608afb060211e3a8">Scopes_e</a> : int32_t { <br />
&#160;&#160;<b>kUndefined</b>
, <b>kMonitor</b>
, <b>kOperate</b>
, <b>kConfig</b>
, <br />
&#160;&#160;<b>kAdmin</b>
<br />
 }</td></tr>
<tr class="memdesc:a52e17ef3ce00a51e608afb060211e3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scopes_e is an enumeration of the different access scopes that a device supports. <br /></td></tr>
<tr class="separator:a52e17ef3ce00a51e608afb060211e3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acf5cbe5ba25dfe830f1a028899593c69" id="r_acf5cbe5ba25dfe830f1a028899593c69"><td class="memTemplParams" colspan="2"><a id="acf5cbe5ba25dfe830f1a028899593c69" name="acf5cbe5ba25dfe830f1a028899593c69"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf5cbe5ba25dfe830f1a028899593c69"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getParamValue</b> (<a class="el" href="classcatena_1_1common_1_1IParam.html">catena::common::IParam</a> *param)</td></tr>
<tr class="separator:acf5cbe5ba25dfe830f1a028899593c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7051c03c402f50294ffebece8d0cfb" id="r_aaf7051c03c402f50294ffebece8d0cfb"><td class="memItemLeft" align="right" valign="top"><a id="aaf7051c03c402f50294ffebece8d0cfb" name="aaf7051c03c402f50294ffebece8d0cfb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>timeNow</b> ()</td></tr>
<tr class="memdesc:aaf7051c03c402f50294ffebece8d0cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current time as a string including microseconds. <br /></td></tr>
<tr class="separator:aaf7051c03c402f50294ffebece8d0cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f6e68869990f230baee7774d764623" id="r_a78f6e68869990f230baee7774d764623"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a78f6e68869990f230baee7774d764623"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecatena_1_1common.html#a78f6e68869990f230baee7774d764623">toProto</a> (catena::Value &amp;dst, const T *src, const <a class="el" href="classcatena_1_1common_1_1ParamDescriptor.html">ParamDescriptor</a> &amp;pd, const <a class="el" href="classcatena_1_1common_1_1Authorizer.html">Authorizer</a> &amp;authz)</td></tr>
<tr class="separator:a78f6e68869990f230baee7774d764623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028c90c48c39454968736c95d2c0ceb9" id="r_a028c90c48c39454968736c95d2c0ceb9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a028c90c48c39454968736c95d2c0ceb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecatena_1_1common.html#a028c90c48c39454968736c95d2c0ceb9">fromProto</a> (const catena::Value &amp;src, T *dst, const <a class="el" href="classcatena_1_1common_1_1ParamDescriptor.html">ParamDescriptor</a> &amp;pd, const <a class="el" href="classcatena_1_1common_1_1Authorizer.html">Authorizer</a> &amp;authz)</td></tr>
<tr class="separator:a028c90c48c39454968736c95d2c0ceb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addddb371559a45d42994973db1a69f08" id="r_addddb371559a45d42994973db1a69f08"><td class="memTemplParams" colspan="2">template&lt;std::size_t size&gt; </td></tr>
<tr class="memitem:addddb371559a45d42994973db1a69f08"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecatena_1_1common.html#addddb371559a45d42994973db1a69f08">_findTypeIndex</a> (const std::string &amp;typeName, const std::array&lt; const char *, size &gt; &amp;typeNames)</td></tr>
<tr class="memdesc:addddb371559a45d42994973db1a69f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to find the index of a type in a list of type names  <br /></td></tr>
<tr class="separator:addddb371559a45d42994973db1a69f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f37737db27ab4b01982ea3514500fb0" id="r_a2f37737db27ab4b01982ea3514500fb0"><td class="memTemplParams" colspan="2">template&lt;meta::IsVariant V, std::size_t Index&gt; </td></tr>
<tr class="memitem:a2f37737db27ab4b01982ea3514500fb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecatena_1_1common.html#a2f37737db27ab4b01982ea3514500fb0">_changeType</a> (V &amp;variant, const std::size_t newTypeIndex)</td></tr>
<tr class="memdesc:a2f37737db27ab4b01982ea3514500fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">_changeType is a helper function to change the type held by a variant  <br /></td></tr>
<tr class="separator:a2f37737db27ab4b01982ea3514500fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a04d8e05178c122255bb9676c064c15a8" id="r_a04d8e05178c122255bb9676c064c15a8"><td class="memItemLeft" align="right" valign="top"><a id="a04d8e05178c122255bb9676c064c15a8" name="a04d8e05178c122255bb9676c064c15a8"></a>
constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>kDefaultMaxArrayLength</b> {1024}</td></tr>
<tr class="memdesc:a04d8e05178c122255bb9676c064c15a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default limit for param array accesses. <br /></td></tr>
<tr class="separator:a04d8e05178c122255bb9676c064c15a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb3e8a8f510a27e9a83ef3f075ac225" id="r_a2cb3e8a8f510a27e9a83ef3f075ac225"><td class="memItemLeft" align="right" valign="top"><a id="a2cb3e8a8f510a27e9a83ef3f075ac225" name="a2cb3e8a8f510a27e9a83ef3f075ac225"></a>
<a class="el" href="structcatena_1_1common_1_1EmptyValue.html">EmptyValue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>emptyValue</b></td></tr>
<tr class="separator:a2cb3e8a8f510a27e9a83ef3f075ac225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a9d30ba7a22910857f12f13ed809cc" id="r_a50a9d30ba7a22910857f12f13ed809cc"><td class="memTemplParams" colspan="2">template&lt;meta::IsVariant U&gt; </td></tr>
<tr class="memitem:a50a9d30ba7a22910857f12f13ed809cc"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; const char *, 0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecatena_1_1common.html#a50a9d30ba7a22910857f12f13ed809cc">alternativeNames</a> {}</td></tr>
<tr class="memdesc:a50a9d30ba7a22910857f12f13ed809cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">AltenativeNames is specialized in the generated code to provide the names of the alternatives in a variant.  <br /></td></tr>
<tr class="separator:a50a9d30ba7a22910857f12f13ed809cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functionality that can be shared between the different connection management types. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2f37737db27ab4b01982ea3514500fb0" name="a2f37737db27ab4b01982ea3514500fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f37737db27ab4b01982ea3514500fb0">&#9670;&#160;</a></span>_changeType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;meta::IsVariant V, std::size_t Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void catena::common::_changeType </td>
          <td>(</td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>variant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>newTypeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>_changeType is a helper function to change the type held by a variant </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of the variant </td></tr>
    <tr><td class="paramname">Index</td><td>the index of the current type being checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variant</td><td>the variant to change the type of </td></tr>
    <tr><td class="paramname">newTypeIndex</td><td>the index of the new type to change to</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by fromProto to change the type of a variant to the type specified in the src protobuf message. It is a recursive function that checks each type in the variant until it finds the type that matches the newTypeIndex. If the type is not found, the variant is left unchanged. If the type is found, the variant is changed to the default value of the new type. </p>

</div>
</div>
<a id="addddb371559a45d42994973db1a69f08" name="addddb371559a45d42994973db1a69f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addddb371559a45d42994973db1a69f08">&#9670;&#160;</a></span>_findTypeIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t catena::common::_findTypeIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>typeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; const char *, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>typeNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function to find the index of a type in a list of type names </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeName</td><td>the name of the type to find </td></tr>
    <tr><td class="paramname">typeNames</td><td>the list of type names to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the type in the list or the size of the list if the type is not found </dd></dl>

</div>
</div>
<a id="a028c90c48c39454968736c95d2c0ceb9" name="a028c90c48c39454968736c95d2c0ceb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028c90c48c39454968736c95d2c0ceb9">&#9670;&#160;</a></span>fromProto()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void catena::common::fromProto </td>
          <td>(</td>
          <td class="paramtype">const catena::Value &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcatena_1_1common_1_1ParamDescriptor.html">ParamDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>pd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcatena_1_1common_1_1Authorizer.html">Authorizer</a> &amp;&#160;</td>
          <td class="paramname"><em>authz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free standing method to deserialize a value from protobuf</p>
<p>generic template declaration</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the value</td></tr>
  </table>
  </dd>
</dl>
<p>fromProto specialization to deserialize an entire array of structured data from protobuf</p>
<p>enabled if T is a vector of struct with isCatenaStruct defined</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the value</td></tr>
  </table>
  </dd>
</dl>
<p>fromProto specialization to deserialize a single struct value from protobuf.</p>
<p>recursively calls fromProto for each field in the struct</p>
<p>enabled if T has isCatenaStruct defined</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the value </td></tr>
  </table>
  </dd>
</dl>
<p>&amp;(dst-&gt;*(field.memberPtr)) will pass the address of the corresponding value field in dst to the fromProto function.</p>
<p>the correct specialization of fromProto will be called based on the type of the field memberPtr.</p>
<p>&amp;(dst-&gt;*(field.memberPtr)) will pass the address of the corresponding value field in dst to the fromProto function.</p>
<p>the correct specialization of fromProto will be called based on the type of the field memberPtr.</p>

<p class="reference">References <a class="el" href="namespacecatena_1_1common.html#a028c90c48c39454968736c95d2c0ceb9">fromProto()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacecatena_1_1common_a028c90c48c39454968736c95d2c0ceb9_cgraph.svg" width="215" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacecatena_1_1common_a028c90c48c39454968736c95d2c0ceb9_icgraph.svg" width="215" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a78f6e68869990f230baee7774d764623" name="a78f6e68869990f230baee7774d764623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f6e68869990f230baee7774d764623">&#9670;&#160;</a></span>toProto()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void catena::common::toProto </td>
          <td>(</td>
          <td class="paramtype">catena::Value &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcatena_1_1common_1_1ParamDescriptor.html">ParamDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>pd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcatena_1_1common_1_1Authorizer.html">Authorizer</a> &amp;&#160;</td>
          <td class="paramname"><em>authz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free standing method to serialize a value to protobuf</p>
<p>generic template declaration</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the value</td></tr>
  </table>
  </dd>
</dl>
<p>toProto specialization to serialize an entire array of structured data to protobuf</p>
<p>enabled if T is a vector of CatenaStruct</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the value</td></tr>
  </table>
  </dd>
</dl>
<p>toProto specialization to serialize a single struct value to protobuf.</p>
<p>recursively calls toProto for each field in the struct</p>
<p>enabled if T has matches the CatenaStruct concept</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the value </td></tr>
  </table>
  </dd>
</dl>
<p>&amp;(src-&gt;*(field.memberPtr)) will pass the address of the corresponding field in src to the toProto function.</p>
<p>the correct specializtion of toProto will be called based on the type of the field memberPtr.</p>
<p>&amp;(src-&gt;*(field.memberPtr)) will pass the address of the corresponding field in src to the toProto function.</p>
<p>the correct specializtion of toProto will be called based on the type of the field memberPtr.</p>

<p class="reference">References <a class="el" href="namespacecatena_1_1common.html#a78f6e68869990f230baee7774d764623">toProto()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacecatena_1_1common_a78f6e68869990f230baee7774d764623_cgraph.svg" width="198" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacecatena_1_1common_a78f6e68869990f230baee7774d764623_icgraph.svg" width="198" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a50a9d30ba7a22910857f12f13ed809cc" name="a50a9d30ba7a22910857f12f13ed809cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a9d30ba7a22910857f12f13ed809cc">&#9670;&#160;</a></span>alternativeNames</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;meta::IsVariant U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;const char*, 0&gt; catena::common::alternativeNames {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AltenativeNames is specialized in the generated code to provide the names of the alternatives in a variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of the variant</td></tr>
  </table>
  </dd>
</dl>
<p>The Catena code generator will specialize this template for every variant in the json device model that does not have a template_oid. The specialization will contain a vector of strings that contains the names of each alternative in the variant. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecatena.html">catena</a></li><li class="navelem"><a class="el" href="namespacecatena_1_1common.html">common</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
