<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Catena_cpp-v0.0.1: /home/runner/work/Catena/Catena/sdks/cpp/common/include/StructInfo.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="doxylogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Catena_cpp-v0.0.1
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('StructInfo_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">StructInfo.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Structured data serialization and deserialization to protobuf.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;meta/Typelist.h&gt;</code><br />
<code>#include &lt;meta/IsVector.h&gt;</code><br />
<code>#include &lt;<a class="el" href="Variant_8h_source.html">meta/Variant.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="AuthzInfo_8h_source.html">AuthzInfo.h</a>&gt;</code><br />
<code>#include &lt;interface/param.pb.h&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for StructInfo.h:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="StructInfo_8h__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="StructInfo_8h__dep__incl.svg" width="207" height="171"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div>
<p><a href="StructInfo_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcatena_1_1common_1_1EmptyValue.html">catena::common::EmptyValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcatena_1_1common_1_1EmptyValue.html" title="EmptyValue is used for commands that do not have a value.">EmptyValue</a> is used for commands that do not have a value.  <a href="structcatena_1_1common_1_1EmptyValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcatena_1_1common_1_1StructInfo.html">catena::common::StructInfo&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcatena_1_1common_1_1StructInfo.html" title="StructInfo is specialized at compile time to provide type information about a struct.">StructInfo</a> is specialized at compile time to provide type information about a struct.  <a href="structcatena_1_1common_1_1StructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcatena_1_1common_1_1FieldInfo.html">catena::common::FieldInfo&lt; FieldType, StructType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcatena_1_1common_1_1FieldInfo.html" title="FieldInfo pairs the name of a field with the type information needed to access it.">FieldInfo</a> pairs the name of a field with the type information needed to access it.  <a href="structcatena_1_1common_1_1FieldInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecatena"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecatena.html">catena</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad5292ff814155acd5c7a9bf7b6dcb086"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad5292ff814155acd5c7a9bf7b6dcb086"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="StructInfo_8h.html#ad5292ff814155acd5c7a9bf7b6dcb086">catena::common::toProto</a> (catena::Value &amp;dst, const T *src, const AuthzInfo &amp;auth)</td></tr>
<tr class="separator:ad5292ff814155acd5c7a9bf7b6dcb086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00607bf87da6b8329a669b7712191aea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00607bf87da6b8329a669b7712191aea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="StructInfo_8h.html#a00607bf87da6b8329a669b7712191aea">catena::common::fromProto</a> (const catena::Value &amp;src, T *dst, const AuthzInfo &amp;auth)</td></tr>
<tr class="separator:a00607bf87da6b8329a669b7712191aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addddb371559a45d42994973db1a69f08"><td class="memTemplParams" colspan="2">template&lt;std::size_t size&gt; </td></tr>
<tr class="memitem:addddb371559a45d42994973db1a69f08"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="StructInfo_8h.html#addddb371559a45d42994973db1a69f08">catena::common::_findTypeIndex</a> (const std::string &amp;typeName, const std::array&lt; const char *, size &gt; &amp;typeNames)</td></tr>
<tr class="memdesc:addddb371559a45d42994973db1a69f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to find the index of a type in a list of type names  <a href="StructInfo_8h.html#addddb371559a45d42994973db1a69f08">More...</a><br /></td></tr>
<tr class="separator:addddb371559a45d42994973db1a69f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f37737db27ab4b01982ea3514500fb0"><td class="memTemplParams" colspan="2">template&lt;meta::IsVariant V, std::size_t Index&gt; </td></tr>
<tr class="memitem:a2f37737db27ab4b01982ea3514500fb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="StructInfo_8h.html#a2f37737db27ab4b01982ea3514500fb0">catena::common::_changeType</a> (V &amp;variant, const std::size_t newTypeIndex)</td></tr>
<tr class="memdesc:a2f37737db27ab4b01982ea3514500fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">_changeType is a helper function to change the type held by a variant  <a href="StructInfo_8h.html#a2f37737db27ab4b01982ea3514500fb0">More...</a><br /></td></tr>
<tr class="separator:a2f37737db27ab4b01982ea3514500fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2cb3e8a8f510a27e9a83ef3f075ac225"><td class="memItemLeft" align="right" valign="top"><a id="a2cb3e8a8f510a27e9a83ef3f075ac225"></a>
EmptyValue&#160;</td><td class="memItemRight" valign="bottom"><b>catena::common::emptyValue</b></td></tr>
<tr class="separator:a2cb3e8a8f510a27e9a83ef3f075ac225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dc399d594567ca24de123a1b1d60ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38dc399d594567ca24de123a1b1d60ed"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="StructInfo_8h.html#a38dc399d594567ca24de123a1b1d60ed">catena::common::CatenaStruct</a></td></tr>
<tr class="memdesc:a38dc399d594567ca24de123a1b1d60ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">CatenaStruct concept checks that a type is a struct generated by the Catena code generator.  <a href="StructInfo_8h.html#a38dc399d594567ca24de123a1b1d60ed">More...</a><br /></td></tr>
<tr class="separator:a38dc399d594567ca24de123a1b1d60ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b2debe7a9500b22904ee7e342ce5a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad8b2debe7a9500b22904ee7e342ce5a0"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="StructInfo_8h.html#ad8b2debe7a9500b22904ee7e342ce5a0">catena::common::CatenaStructArray</a> = meta::IsVector&lt;T&gt; &amp;&amp; CatenaStruct&lt;typename T::value_type&gt;</td></tr>
<tr class="memdesc:ad8b2debe7a9500b22904ee7e342ce5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">CatenaStructArray concept checks that a type is a vector of structs that meet the CatenaStruct concept.  <a href="StructInfo_8h.html#ad8b2debe7a9500b22904ee7e342ce5a0">More...</a><br /></td></tr>
<tr class="separator:ad8b2debe7a9500b22904ee7e342ce5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc43af7a295408f1bb3bf54a5a68f63"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acfc43af7a295408f1bb3bf54a5a68f63"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="StructInfo_8h.html#acfc43af7a295408f1bb3bf54a5a68f63">catena::common::IsVariantArray</a> = meta::IsVector&lt;T&gt; &amp;&amp; meta::IsVariant&lt;typename T::value_type&gt;</td></tr>
<tr class="memdesc:acfc43af7a295408f1bb3bf54a5a68f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">IsVariantArray concept checks that a type is a vector of variants.  <a href="StructInfo_8h.html#acfc43af7a295408f1bb3bf54a5a68f63">More...</a><br /></td></tr>
<tr class="separator:acfc43af7a295408f1bb3bf54a5a68f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd17517971565e6bf5adb909d6d48f8f"><td class="memTemplParams" colspan="2">template&lt;meta::IsVariant U&gt; </td></tr>
<tr class="memitem:afd17517971565e6bf5adb909d6d48f8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; const char *, 0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="StructInfo_8h.html#afd17517971565e6bf5adb909d6d48f8f">catena::common::alternativeNames</a> {}</td></tr>
<tr class="memdesc:afd17517971565e6bf5adb909d6d48f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">AltenativeNames is specialized in the generated code to provide the names of the alternatives in a variant.  <a href="StructInfo_8h.html#afd17517971565e6bf5adb909d6d48f8f">More...</a><br /></td></tr>
<tr class="separator:afd17517971565e6bf5adb909d6d48f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Structured data serialization and deserialization to protobuf. </p>
<dl class="section author"><dt>Author</dt><dd>John R. Naylor </dd>
<dd>
John Danen </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2024-07-07 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2f37737db27ab4b01982ea3514500fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f37737db27ab4b01982ea3514500fb0">&#9670;&nbsp;</a></span>_changeType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;meta::IsVariant V, std::size_t Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void catena::common::_changeType </td>
          <td>(</td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>variant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>newTypeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>_changeType is a helper function to change the type held by a variant </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of the variant </td></tr>
    <tr><td class="paramname">Index</td><td>the index of the current type being checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variant</td><td>the variant to change the type of </td></tr>
    <tr><td class="paramname">newTypeIndex</td><td>the index of the new type to change to</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used by fromProto to change the type of a variant to the type specified in the src protobuf message. It is a recursive function that checks each type in the variant until it finds the type that matches the newTypeIndex. If the type is not found, the variant is left unchanged. If the type is found, the variant is changed to the default value of the new type. </p>

<p class="reference">References <a class="el" href="StructInfo_8h.html#a2f37737db27ab4b01982ea3514500fb0">catena::common::_changeType()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="StructInfo_8h_a2f37737db27ab4b01982ea3514500fb0_cgraph.svg" width="234" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="StructInfo_8h_a2f37737db27ab4b01982ea3514500fb0_icgraph.svg" width="234" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="addddb371559a45d42994973db1a69f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addddb371559a45d42994973db1a69f08">&#9670;&nbsp;</a></span>_findTypeIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t catena::common::_findTypeIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>typeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; const char *, size &gt; &amp;&#160;</td>
          <td class="paramname"><em>typeNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function to find the index of a type in a list of type names </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeName</td><td>the name of the type to find </td></tr>
    <tr><td class="paramname">typeNames</td><td>the list of type names to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the type in the list or the size of the list if the type is not found </dd></dl>

<p class="reference">References <a class="el" href="StructInfo_8h.html#addddb371559a45d42994973db1a69f08">catena::common::_findTypeIndex()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="StructInfo_8h_addddb371559a45d42994973db1a69f08_cgraph.svg" width="211" height="76"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="StructInfo_8h_addddb371559a45d42994973db1a69f08_icgraph.svg" width="211" height="76"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a00607bf87da6b8329a669b7712191aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00607bf87da6b8329a669b7712191aea">&#9670;&nbsp;</a></span>fromProto()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void catena::common::fromProto </td>
          <td>(</td>
          <td class="paramtype">const catena::Value &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcatena_1_1common_1_1AuthzInfo.html">AuthzInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>auth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free standing method to deserialize a value from protobuf</p>
<p>generic template declaration</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the value</td></tr>
  </table>
  </dd>
</dl>
<p>fromProto specialization to deserialize an entire array of structured data from protobuf</p>
<p>enabled if T is a vector of struct with isCatenaStruct defined</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the value</td></tr>
  </table>
  </dd>
</dl>
<p>fromProto specialization to deserialize a single struct value from protobuf.</p>
<p>recursively calls fromProto for each field in the struct</p>
<p>enabled if T has isCatenaStruct defined</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the value </td></tr>
  </table>
  </dd>
</dl>
<p>&amp;(dst-&gt;*(field.memberPtr)) will pass the address of the corresponding value field in dst to the fromProto function.</p>
<p>the correct specialization of fromProto will be called based on the type of the field memberPtr.</p>
<p>&amp;(dst-&gt;*(field.memberPtr)) will pass the address of the corresponding value field in dst to the fromProto function.</p>
<p>the correct specialization of fromProto will be called based on the type of the field memberPtr.</p>

<p class="reference">References <a class="el" href="StructInfo_8h.html#a00607bf87da6b8329a669b7712191aea">catena::common::fromProto()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="StructInfo_8h_a00607bf87da6b8329a669b7712191aea_cgraph.svg" width="215" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="StructInfo_8h_a00607bf87da6b8329a669b7712191aea_icgraph.svg" width="215" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad5292ff814155acd5c7a9bf7b6dcb086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5292ff814155acd5c7a9bf7b6dcb086">&#9670;&nbsp;</a></span>toProto()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void catena::common::toProto </td>
          <td>(</td>
          <td class="paramtype">catena::Value &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcatena_1_1common_1_1AuthzInfo.html">AuthzInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>auth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free standing method to serialize a value to protobuf</p>
<p>generic template declaration</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the value</td></tr>
  </table>
  </dd>
</dl>
<p>toProto specialization to serialize an entire array of structured data to protobuf</p>
<p>enabled if T is a vector of CatenaStruct</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the value</td></tr>
  </table>
  </dd>
</dl>
<p>toProto specialization to serialize a single struct value to protobuf.</p>
<p>recursively calls toProto for each field in the struct</p>
<p>enabled if T has matches the CatenaStruct concept</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the value </td></tr>
  </table>
  </dd>
</dl>
<p>&amp;(src-&gt;*(field.memberPtr)) will pass the address of the corresponding field in src to the toProto function.</p>
<p>the correct specializtion of toProto will be called based on the type of the field memberPtr.</p>
<p>&amp;(src-&gt;*(field.memberPtr)) will pass the address of the corresponding field in src to the toProto function.</p>
<p>the correct specializtion of toProto will be called based on the type of the field memberPtr.</p>

<p class="reference">References <a class="el" href="StructInfo_8h.html#ad5292ff814155acd5c7a9bf7b6dcb086">catena::common::toProto()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="StructInfo_8h_ad5292ff814155acd5c7a9bf7b6dcb086_cgraph.svg" width="198" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="StructInfo_8h_ad5292ff814155acd5c7a9bf7b6dcb086_icgraph.svg" width="198" height="62"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="afd17517971565e6bf5adb909d6d48f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd17517971565e6bf5adb909d6d48f8f">&#9670;&nbsp;</a></span>alternativeNames</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;meta::IsVariant U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt;const char*, 0&gt; catena::common::alternativeNames {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AltenativeNames is specialized in the generated code to provide the names of the alternatives in a variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of the variant</td></tr>
  </table>
  </dd>
</dl>
<p>The Catena code generator will specialize this template for every variant in the json device model that does not have a template_oid. The specialization will contain a vector of strings that contains the names of each alternative in the variant. </p>

</div>
</div>
<a id="a38dc399d594567ca24de123a1b1d60ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38dc399d594567ca24de123a1b1d60ed">&#9670;&nbsp;</a></span>CatenaStruct</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept catena::common::CatenaStruct</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= requires {</div>
<div class="line">    <span class="keyword">typename</span> T::isCatenaStruct;</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>CatenaStruct concept checks that a type is a struct generated by the Catena code generator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to check</td></tr>
  </table>
  </dd>
</dl>
<p>This concept is used to specialize template functions for any struct type generated by the Catena code generator. The Catena code generator will add a using declaration to the struct that defines isCatenaStruct as a type. This concept checks for the presence of that type.</p>
<p>all types that meet this constraint will also provide a specialization of StructInfo. </p>

</div>
</div>
<a id="ad8b2debe7a9500b22904ee7e342ce5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b2debe7a9500b22904ee7e342ce5a0">&#9670;&nbsp;</a></span>CatenaStructArray</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept catena::common::CatenaStructArray = meta::IsVector&lt;T&gt; &amp;&amp; CatenaStruct&lt;typename T::value_type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CatenaStructArray concept checks that a type is a vector of structs that meet the CatenaStruct concept. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to check</td></tr>
  </table>
  </dd>
</dl>
<p>This concept is used to specialize template functions for any vector of struct type generated by the Catena code generator. </p>

</div>
</div>
<a id="acfc43af7a295408f1bb3bf54a5a68f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc43af7a295408f1bb3bf54a5a68f63">&#9670;&nbsp;</a></span>IsVariantArray</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept catena::common::IsVariantArray = meta::IsVector&lt;T&gt; &amp;&amp; meta::IsVariant&lt;typename T::value_type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IsVariantArray concept checks that a type is a vector of variants. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to check</td></tr>
  </table>
  </dd>
</dl>
<p>This concept is used to specialize template functions for any vector of variant type generated by the Catena code generator. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_bdd9a5d540de89e9fe90efdfc6973a4f.html">common</a></li><li class="navelem"><a class="el" href="dir_11fbc4217d50ab21044e5ad6614aede5.html">include</a></li><li class="navelem"><a class="el" href="StructInfo_8h.html">StructInfo.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
