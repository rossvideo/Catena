#pragma once

/*
 * Copyright 2024 Ross Video Ltd
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * RE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @file StructInfo.h
 * @brief Structured data serialization and deserialization to protobuf
 * @author John R. Naylor
 * @author John Danen
 * @date 2024-07-07
 */

// common
#include <meta/Typelist.h>
#include <meta/IsVector.h>
#include <meta/Variant.h>
#include <Authorization.h>

// protobuf interface
#include <interface/param.pb.h>

// std
#include <string>
#include <cstddef>
#include <vector>
#include <utility>

namespace catena {
namespace common {

/**
 * @brief EmptyValue is used for commands that do not have a value
 */
struct EmptyValue {};
extern EmptyValue emptyValue;

/**
 * @brief CatenaStruct concept checks that a type is a struct generated by the
 * Catena code generator
 * @tparam T the type to check
 * 
 * This concept is used to specialize template functions for any struct type
 * generated by the Catena code generator. The Catena code generator will add
 * a using declaration to the struct that defines isCatenaStruct as a type.
 * This concept checks for the presence of that type.
 * 
 * all types that meet this constraint will also provide a specialization of
 * StructInfo.
 */
template <typename T>
concept CatenaStruct = requires {
    typename T::isCatenaStruct;
};

/**
 * @brief CatenaStructArray concept checks that a type is a vector of structs
 * that meet the CatenaStruct concept
 * @tparam T the type to check
 * 
 * This concept is used to specialize template functions for any vector of
 * struct type generated by the Catena code generator. 
 */
template <typename T>
concept CatenaStructArray = meta::IsVector<T> && CatenaStruct<typename T::value_type>;

/**
 * @brief IsVariantArray concept checks that a type is a vector of variants
 * @tparam T the type to check
 * 
 * This concept is used to specialize template functions for any vector of
 * variant type generated by the Catena code generator. 
 */
template <typename T>
concept IsVariantArray = meta::IsVector<T> && meta::IsVariant<typename T::value_type>;

/**
 * @brief StructInfo is specialized at compile time to provide type information
 * about a struct
 * @tparam T the type of the struct
 * 
 * The Catena code generator will specialize this template for every struct in
 * the json device model that does not have a template_oid. The specialization
 * will contain a tuple of FieldInfo structs that contains the name and type
 * information of each field in the struct.
 */
template <CatenaStruct T>
struct StructInfo{}; // intentionally undefined

/**
 * @brief FieldInfo pairs the name of a field with the type information needed
 * to access it
 * @tparam FieldType the type of the field
 * @tparam StructType the type of the struct that contains the field
 *
 * The information provided by FieldInfo is used to navigate to sub-params via
 * template metaprogramming.
 */
template <typename FieldType, CatenaStruct StructType>
struct FieldInfo {
    using Field = FieldType;
    const char* name; /*< the name of the field */
    FieldType StructType::* memberPtr; /*< the field's offset from the base of its enclosing struct */

    constexpr FieldInfo(const char* n, FieldType StructType::* m)
        : name(n), memberPtr(m) {}
};

/**
 * @brief AltenativeNames is specialized in the generated code to provide the
 * names of the alternatives in a variant
 * @tparam U the type of the variant
 * 
 * The Catena code generator will specialize this template for every variant in
 * the json device model that does not have a template_oid. The specialization
 * will contain a vector of strings that contains the names of each alternative
 * in the variant.
 */
template <meta::IsVariant U> 
inline std::array<const char*, 0> alternativeNames{};

/**
 * Free standing method to serialize a value to protobuf
 * 
 * generic template declaration
 * 
 * @tparam T the type of the value
 */
template <typename T>
catena::exception_with_status toProto(catena::Value& dst, const T* src, const IParamDescriptor& pd, const Authorizer& authz);

/**
 * Free standing method to validate a call to fromProto before making it.
 * 
 * generic template declaration
 * 
 * @tparam T the type of the value
 */
template <typename T>
bool validFromProto(const catena::Value& src, const T* dst, const IParamDescriptor& pd, catena::exception_with_status& rc, const Authorizer& authz);

/**
 * Free standing method to deserialize a value from protobuf
 * 
 * generic template declaration
 * 
 * @tparam T the type of the value
 */
template <typename T>
catena::exception_with_status fromProto(const catena::Value& src, T* dst, const IParamDescriptor& pd, const Authorizer& authz);

/**
 * toProto specialization to serialize a single struct value to protobuf.
 * 
 * recursively calls toProto for each field in the struct
 * 
 * enabled if T has matches the CatenaStruct concept
 * 
 * @tparam T the type of the value
 */
template <CatenaStruct T>
catena::exception_with_status toProto(catena::Value& dst, const T* src, const IParamDescriptor& pd, const Authorizer& authz) {
    catena::exception_with_status rc{"", catena::StatusCode::OK};
    // Must have read authorization
    if (!authz.readAuthz(pd)) {
        rc = catena::exception_with_status("Not authorized to read param " + pd.getOid(), catena::StatusCode::PERMISSION_DENIED);
    } else {
        dst.clear_struct_value();
        auto fields = StructInfo<T>::fields; // get tuple of FieldInfo for this struct type
        auto* dstFields = dst.mutable_struct_value()->mutable_fields();

        // lambda function to call toProto for the given field if it is authorized
        auto readField = [&](const auto& field) {
            if (rc.status == catena::StatusCode::OK) {
                IParamDescriptor& subParam = pd.getSubParam(field.name);
                catena::Value* newFieldValue = &(*dstFields)[field.name];

                /**
                 * &(src->*(field.memberPtr)) will pass the address of the
                 * corresponding field in src to the toProto function.
                 * 
                 * the correct specializtion of toProto will be called based on the
                 * type of the field memberPtr. 
                 */
                rc = toProto(*newFieldValue, &(src->*(field.memberPtr)), subParam, authz);
            }
        };

        // call readField for each field in the struct
        std::apply([&](auto... field) {
            (readField(field), ...);
        }, fields);
    }
    // Return an empty struct if the serialization failed
    if (rc.status != catena::StatusCode::OK) {
        dst.clear_struct_value();
    }
    return rc;
}

template <CatenaStruct T>
bool validFromProto(const catena::Value& src, const T* dst, const IParamDescriptor& pd, catena::exception_with_status& rc, const Authorizer& authz) {
    auto fields = StructInfo<T>::fields; // get tuple of FieldInfo for this struct type
    // Must have write authorization
    if (!authz.writeAuthz(pd)) {
        rc = catena::exception_with_status("Not authorized to write to param " + pd.getOid(), catena::StatusCode::PERMISSION_DENIED);
    // Must have correct type
    } else if (!src.has_struct_value()) {
        rc = catena::exception_with_status("Type mismatch between value and struct " + pd.getOid(), catena::StatusCode::INVALID_ARGUMENT);
    } else {
        auto& srcFields = src.struct_value().fields();
        // lambda function to call validFromProto for the given field
        auto testWriteField = [&](const auto& field) {
            IParamDescriptor& subParam = pd.getSubParam(field.name);
            if (rc.status == catena::StatusCode::OK) {
                // Must contain all the field
                if (!srcFields.contains(field.name)) {
                    rc = catena::exception_with_status(pd.getOid() + " does not contain field " + field.name, catena::StatusCode::INVALID_ARGUMENT);
                } else {
                    validFromProto(srcFields.at(field.name), &(dst->*(field.memberPtr)), subParam, rc, authz);
                }
            }
        };
        // All sub params must also be valid.
        std::apply([&](auto... field) {
            (testWriteField(field), ...);
        }, fields);
    }
    return rc.status == catena::StatusCode::OK;
}

/**
 * fromProto specialization to deserialize a single struct value from protobuf.
 * 
 * recursively calls fromProto for each field in the struct
 * 
 * enabled if T has isCatenaStruct defined
 * 
 * @tparam T the type of the value
 */
template <CatenaStruct T>
catena::exception_with_status fromProto(const catena::Value& src, T* dst, const IParamDescriptor& pd, const Authorizer& authz) {
    catena::exception_with_status rc{"", catena::StatusCode::OK};
    if (validFromProto(src, dst, pd, rc, authz)) {
        auto fields = StructInfo<T>::fields; // get tuple of FieldInfo for this struct type
        auto& srcFields = src.struct_value().fields();

        // lambda function to call fromProto for the given field if it is authorized
        auto writeField = [&](const auto& field) {
            IParamDescriptor& subParam = pd.getSubParam(field.name);
            /**
             * &(dst->*(field.memberPtr)) will pass the address of the
             * corresponding value field in dst to the fromProto function.
             * 
             * the correct specialization of fromProto will be called based on
             * the type of the field memberPtr.
             */
            fromProto(srcFields.at(field.name), &(dst->*(field.memberPtr)), subParam, authz);
        };

        // call writeField for each field in the dst struct
        // If the src value contains a field that is not in the dst struct, it
        // will be ignored
        std::apply([&](auto... field) {
            (writeField(field), ...);
        }, fields);
    }
    return rc;
}

/**
 * toProto specialization to serialize an entire array of structured data to
 * protobuf
 * 
 * enabled if T is a vector of CatenaStruct
 * 
 * @tparam T the type of the value
 */
template <CatenaStructArray T>
catena::exception_with_status toProto(catena::Value& dst, const T* src, const IParamDescriptor& pd, const Authorizer& authz) {
    catena::exception_with_status rc{"", catena::StatusCode::OK};
    // Must have read authorization
    if (!authz.readAuthz(pd)) {
        rc = catena::exception_with_status("Not authorized to read param " + pd.getOid(), catena::StatusCode::PERMISSION_DENIED);
    } else {
        dst.clear_struct_array_values();
        using structType = T::value_type;
        auto* dstArray = dst.mutable_struct_array_values();
        
        for (const auto& item : *src) {
            catena::Value elemValue;
            rc = toProto(elemValue, &item, pd, authz);
            *dstArray->add_struct_values() = *elemValue.mutable_struct_value();
            if (rc.status != catena::StatusCode::OK) { break; }
        }
    }
    // Return an empty array if the serialization failed
    if (rc.status != catena::StatusCode::OK) {
        dst.clear_struct_array_values();
    }
    return rc;
}

template <CatenaStructArray T>
bool validFromProto(const catena::Value& src, const T* dst, const IParamDescriptor& pd, catena::exception_with_status& rc, const Authorizer& authz) {
    using structType = T::value_type;
    // Must have write authorization
    if (!authz.writeAuthz(pd)) {
        rc = catena::exception_with_status("Not authorized to write to param " + pd.getOid(), catena::StatusCode::PERMISSION_DENIED);
    // Must have correct type
    } else if (!src.has_struct_array_values()) {
        rc = catena::exception_with_status("Type mismatch between value and struct array " + pd.getOid(), catena::StatusCode::INVALID_ARGUMENT);
    // Must not exceed max length.
    } else if (src.struct_array_values().struct_values_size() > pd.max_length()) {
        rc = catena::exception_with_status("Param " + pd.getOid() + " exceeds maximum capacity", catena::StatusCode::OUT_OF_RANGE);
    } else {
        auto& srcArray = src.struct_array_values().struct_values();
        structType testStruct; // Empty struct for testing sub params.
        // All members must also be valid.
        for (int i = 0; i < srcArray.size(); ++i) {
            catena::Value item;
            *item.mutable_struct_value() = srcArray.Get(i);
            if (!validFromProto(item, &testStruct, pd, rc, authz)) {
                break;
            }
        }
    }
    return rc.status == catena::StatusCode::OK;
}

/**
 * fromProto specialization to deserialize an entire array of structured data
 * from protobuf
 * 
 * enabled if T is a vector of struct with isCatenaStruct defined
 * 
 * @tparam T the type of the value
 */
template <CatenaStructArray T>
catena::exception_with_status fromProto(const catena::Value& src, T* dst, const IParamDescriptor& pd, const Authorizer& authz) {
    catena::exception_with_status rc{"", catena::StatusCode::OK};
    if (validFromProto(src, dst, pd, rc, authz)) {
        using structType = T::value_type;
        auto& srcArray = src.struct_array_values().struct_values();
        dst->clear(); // empty the destination vector
        // iterate over each element in the src array and call fromProto for each
        for (int i = 0; i < srcArray.size(); ++i) {
            catena::Value item;
            *item.mutable_struct_value() = srcArray.Get(i);
            structType& elemValue = dst->emplace_back();
            fromProto(item, &elemValue, pd, authz);
        }
    }
    return rc;
}

/**
 * @brief helper function to find the index of a type in a list of type names
 * @param typeName the name of the type to find
 * @param typeNames the list of type names to search
 * @return the index of the type in the list or the size of the list if the
 * type is not found
 */
template <std::size_t size>
inline std::size_t _findTypeIndex(const std::string& typeName, const std::array<const char*, size>& typeNames) {
    return std::find(typeNames.begin(), typeNames.end(), typeName) - typeNames.begin();
}

/**
 * @brief _changeType is a helper function to change the type held by a variant
 * @tparam V the type of the variant
 * @tparam Index the index of the current type being checked
 * @param variant the variant to change the type of
 * @param newTypeIndex the index of the new type to change to
 * 
 * This function is used by fromProto to change the type of a variant to the
 * type specified in the src protobuf message. It is a recursive function that
 * checks each type in the variant until it finds the type that matches the
 * newTypeIndex. If the type is not found, the variant is left unchanged. If
 * the type is found, the variant is changed to the default value of the new
 * type.
 */
template <meta::IsVariant V, std::size_t Index>
void _changeType(V& variant, const std::size_t newTypeIndex) {
    if constexpr (Index != std::variant_size_v<V>) {
        using NewType = std::variant_alternative_t<Index, V>;
        if (newTypeIndex == Index) {
            // found the new type, change the variant to the default value of
            // the new type
            variant = NewType{};
        } else {
            _changeType<V, Index + 1>(variant, newTypeIndex);
        }
    } // else reached the end of the variant, type not found
}

template <meta::IsVariant T>
catena::exception_with_status toProto(catena::Value& dst, const T* src, const IParamDescriptor& pd, const Authorizer& authz) {
    catena::exception_with_status rc{"", catena::StatusCode::OK};
    // Must have read authorization
    if (!authz.readAuthz(pd)) {
        rc = catena::exception_with_status("Not authorized to read param " + pd.getOid(), catena::StatusCode::PERMISSION_DENIED);
    } else {
        dst.clear_struct_variant_value();
        std::string variantType = alternativeNames<T>[src->index()];
        IParamDescriptor& subParam = pd.getSubParam(variantType);
        std::visit([&](auto& arg) {
            if (rc.status == catena::StatusCode::OK) {
                catena::Value elemValue;
                rc = toProto(elemValue, &arg, subParam, authz);
                catena::StructVariantValue* structVariant = dst.mutable_struct_variant_value();
                structVariant->set_struct_variant_type(variantType);
                *structVariant->mutable_value() = elemValue;
            }
        }, *src);
    }
    // Return an empty array if the serialization failed
    if (rc.status != catena::StatusCode::OK) {
        dst.clear_struct_variant_value();
    }
    return rc;
}

template <meta::IsVariant T>
bool validFromProto(const catena::Value& src, const T* dst, const IParamDescriptor& pd, catena::exception_with_status& rc, const Authorizer& authz) {
    // Must have write authorization
    if (!authz.writeAuthz(pd)) {
        rc = catena::exception_with_status("Not authorized to write to param " + pd.getOid(), catena::StatusCode::PERMISSION_DENIED);
    // Must have correct type
    } else if (!src.has_struct_variant_value()) {
        rc = catena::exception_with_status("Type mismatch between value and variant struct " + pd.getOid(), catena::StatusCode::INVALID_ARGUMENT);
    } else {
        const catena::StructVariantValue& srcVariant = src.struct_variant_value();
        std::string variantType = srcVariant.struct_variant_type();
        std::size_t typeIndex = _findTypeIndex(variantType, alternativeNames<T>);
        // Must have valid variant type
        if (typeIndex >= alternativeNames<T>.size()) {
            rc = catena::exception_with_status(pd.getOid() + " does not contain variant " + variantType, catena::StatusCode::INVALID_ARGUMENT);
        } else {
            T testVariant;
            _changeType<T, 0>(testVariant, typeIndex);
            // All sub params must also be valid.
            IParamDescriptor& subParam= pd.getSubParam(variantType);
            std::visit([&](auto& arg) {
                if (rc.status == catena::StatusCode::OK) {
                    validFromProto(srcVariant.value(), &arg, subParam, rc, authz);
                }
            }, testVariant); 
        }
    }
    return rc.status == catena::StatusCode::OK;
}

template <meta::IsVariant T>
catena::exception_with_status fromProto(const catena::Value& src, T* dst, const IParamDescriptor& pd, const Authorizer& authz) {
    catena::exception_with_status rc{"", catena::StatusCode::OK};
    if (validFromProto(src, dst, pd, rc, authz)) {
        const catena::StructVariantValue& srcVariant = src.struct_variant_value();
        std::string variantType = srcVariant.struct_variant_type();
        
        std::size_t typeIndex = _findTypeIndex(variantType, alternativeNames<T>);
        if (typeIndex < alternativeNames<T>.size()) {
            if (typeIndex != dst->index()) {
                // The type of the variant needs to be changed
                _changeType<T, 0>(*dst, typeIndex);
            }

            IParamDescriptor& subParam= pd.getSubParam(variantType);
            std::visit([&](auto& arg) {
                fromProto(srcVariant.value(), &arg, subParam, authz);
            }, *dst); 
        }
    }
    return rc;
}

template <IsVariantArray T>
catena::exception_with_status toProto(catena::Value& dst, const T* src, const IParamDescriptor& pd, const Authorizer& authz) {
    catena::exception_with_status rc{"", catena::StatusCode::OK};
    // Must have read authorization
    if (!authz.readAuthz(pd)) {
        rc = catena::exception_with_status("Not authorized to read param " + pd.getOid(), catena::StatusCode::PERMISSION_DENIED);
    } else {
        dst.clear_struct_variant_array_values();
        for (const auto& item : *src) {
            catena::Value elemValue;
            rc = toProto(elemValue, &item, pd, authz);
            *dst.mutable_struct_variant_array_values()->add_struct_variants() = *elemValue.mutable_struct_variant_value();
            if (rc.status != catena::StatusCode::OK) { break; }
        }
    }
    // Return an empty array if the serialization failed
    if (rc.status != catena::StatusCode::OK) {
        dst.clear_struct_variant_array_values();
    }
    return rc;
}

template <IsVariantArray T>
bool validFromProto(const catena::Value& src, const T* dst, const IParamDescriptor& pd, catena::exception_with_status& rc, const Authorizer& authz) {
    using VariantType = T::value_type;
    // Must have write authorization
    if (!authz.writeAuthz(pd)) {
        rc = catena::exception_with_status("Not authorized to write to param " + pd.getOid(), catena::StatusCode::PERMISSION_DENIED);
    // Must have correct type
    } else if (!src.has_struct_variant_array_values()) {
        rc = catena::exception_with_status("Type mismatch between value and variant struct array " + pd.getOid(), catena::StatusCode::INVALID_ARGUMENT);
    // Must not exceed max length
    } else if (src.struct_variant_array_values().struct_variants_size() > pd.max_length()) {
        rc = catena::exception_with_status("Param " + pd.getOid() + " exceeds maximum capacity", catena::StatusCode::OUT_OF_RANGE);
    } else {
        auto& srcArray = src.struct_variant_array_values().struct_variants();
        // All members must also be valid.
        for (int i = 0; i < srcArray.size(); ++i) {
            VariantType testStruct; // Empty struct for testing.
            catena::Value item;
            *item.mutable_struct_variant_value() = srcArray.Get(i);
            if (!validFromProto(item, &testStruct, pd, rc, authz)) {
                break;
            }
        }
    }
    return rc.status == catena::StatusCode::OK;
}

template <IsVariantArray T>
catena::exception_with_status fromProto(const catena::Value& src, T* dst, const IParamDescriptor& pd, const Authorizer& authz) {
    catena::exception_with_status rc{"", catena::StatusCode::OK};
    if (validFromProto(src, dst, pd, rc, authz)) {
        using VariantType = T::value_type;
        auto& srcArray = src.struct_variant_array_values().struct_variants();
        dst->clear(); // empty the destination vector

        // iterate over each element in the src array and call fromProto for each
        for (int i = 0; i < srcArray.size(); ++i) {
            catena::Value item;
            *item.mutable_struct_variant_value() = srcArray.Get(i);
            VariantType& elemValue = dst->emplace_back();
            fromProto(item, &elemValue, pd, authz);
        }
    }
    return rc;
}

}  // namespace common
}  // namespace catena
