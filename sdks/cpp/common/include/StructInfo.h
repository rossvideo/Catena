#pragma once

/*
 * Copyright 2024 Ross Video Ltd
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * RE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @file StructInfo.h
 * @brief Structured data serialization and deserialization to protobuf
 * @author John R. Naylor
 * @author John Danen
 * @date 2024-07-07
 */

// common
#include <meta/Typelist.h>
#include <meta/IsVector.h>
#include <meta/Variant.h>
#include <Authorization.h>

// protobuf interface
#include <interface/param.pb.h>

// std
#include <string>
#include <cstddef>
#include <vector>
#include <utility>

namespace catena {
namespace common {

/**
 * @brief EmptyValue is used for commands that do not have a value
 */
struct EmptyValue {};
extern EmptyValue emptyValue;

/**
 * @brief CatenaStruct concept checks that a type is a struct generated by the
 * Catena code generator
 * @tparam T the type to check
 * 
 * This concept is used to specialize template functions for any struct type
 * generated by the Catena code generator. The Catena code generator will add
 * a using declaration to the struct that defines isCatenaStruct as a type.
 * This concept checks for the presence of that type.
 * 
 * all types that meet this constraint will also provide a specialization of
 * StructInfo.
 */
template <typename T>
concept CatenaStruct = requires {
    typename T::isCatenaStruct;
};

/**
 * @brief CatenaStructArray concept checks that a type is a vector of structs
 * that meet the CatenaStruct concept
 * @tparam T the type to check
 * 
 * This concept is used to specialize template functions for any vector of
 * struct type generated by the Catena code generator. 
 */
template <typename T>
concept CatenaStructArray = meta::IsVector<T> && CatenaStruct<typename T::value_type>;

/**
 * @brief IsVariantArray concept checks that a type is a vector of variants
 * @tparam T the type to check
 * 
 * This concept is used to specialize template functions for any vector of
 * variant type generated by the Catena code generator. 
 */
template <typename T>
concept IsVariantArray = meta::IsVector<T> && meta::IsVariant<typename T::value_type>;

/**
 * @brief StructInfo is specialized at compile time to provide type information
 * about a struct
 * @tparam T the type of the struct
 * 
 * The Catena code generator will specialize this template for every struct in
 * the json device model that does not have a template_oid. The specialization
 * will contain a tuple of FieldInfo structs that contains the name and type
 * information of each field in the struct.
 */
template <CatenaStruct T>
struct StructInfo{}; // intentionally undefined

/**
 * @brief FieldInfo pairs the name of a field with the type information needed
 * to access it
 * @tparam FieldType the type of the field
 * @tparam StructType the type of the struct that contains the field
 *
 * The information provided by FieldInfo is used to navigate to sub-params via
 * template metaprogramming.
 */
template <typename FieldType, CatenaStruct StructType>
struct FieldInfo {
    using Field = FieldType;
    const char* name; /*< the name of the field */
    FieldType StructType::* memberPtr; /*< the field's offset from the base of its enclosing struct */

    constexpr FieldInfo(const char* n, FieldType StructType::* m)
        : name(n), memberPtr(m) {}
};

/**
 * @brief AltenativeNames is specialized in the generated code to provide the
 * names of the alternatives in a variant
 * @tparam U the type of the variant
 * 
 * The Catena code generator will specialize this template for every variant in
 * the json device model that does not have a template_oid. The specialization
 * will contain a vector of strings that contains the names of each alternative
 * in the variant.
 */
template <meta::IsVariant U> 
inline std::array<const char*, 0> alternativeNames{};

/**
 * Free standing method to serialize a value to protobuf
 * 
 * generic template declaration
 * 
 * @tparam T the type of the value
 */
template <typename T>
void toProto(catena::Value& dst, const T* src, const IParamDescriptor& pd, const Authorizer& authz);

/**
 * toProto specialization to serialize an entire array of structured data to
 * protobuf
 * 
 * enabled if T is a vector of CatenaStruct
 * 
 * @tparam T the type of the value
 */
template <CatenaStructArray T>
void toProto(catena::Value& dst, const T* src, const IParamDescriptor& pd, const Authorizer& authz) {
    using structType = T::value_type;
    auto* dstArray = dst.mutable_struct_array_values();
    
    for (const auto& item : *src) {
        catena::Value elemValue;
        toProto(elemValue, &item, pd, authz);
        *dstArray->add_struct_values() = *elemValue.mutable_struct_value();
    }
}

/**
 * toProto specialization to serialize a single struct value to protobuf.
 * 
 * recursively calls toProto for each field in the struct
 * 
 * enabled if T has matches the CatenaStruct concept
 * 
 * @tparam T the type of the value
 */
template <CatenaStruct T>
void toProto(catena::Value& dst, const T* src, const IParamDescriptor& pd, const Authorizer& authz) {
    
    auto fields = StructInfo<T>::fields; // get tuple of FieldInfo for this struct type
    auto* dstFields = dst.mutable_struct_value()->mutable_fields();

    // lambda function to call toProto for the given field if it is authorized
    auto readField = [&](const auto& field) {
        IParamDescriptor& subParam = pd.getSubParam(field.name);
        if (authz.readAuthz(subParam)) {
            catena::Value* newFieldValue = &(*dstFields)[field.name];

            /**
             * &(src->*(field.memberPtr)) will pass the address of the
             * corresponding field in src to the toProto function.
             * 
             * the correct specializtion of toProto will be called based on the
             * type of the field memberPtr. 
             */
            toProto(*newFieldValue, &(src->*(field.memberPtr)), subParam, authz);
        }
    };

    // call readField for each field in the struct
    std::apply([&](auto... field) {
        (readField(field), ...);
    }, fields);
}

template <IsVariantArray T>
void toProto(catena::Value& dst, const T* src, const IParamDescriptor& pd, const Authorizer& authz) {
    for (const auto& item : *src) {
        catena::Value elemValue;
        toProto(elemValue, &item, pd, authz);
        *dst.mutable_struct_variant_array_values()->add_struct_variants() = *elemValue.mutable_struct_variant_value();
    }
}

template <meta::IsVariant T>
void toProto(catena::Value& dst, const T* src, const IParamDescriptor& pd, const Authorizer& authz) {
    std::string variantType = alternativeNames<T>[src->index()];
    IParamDescriptor& subParam = pd.getSubParam(variantType);
    std::visit([&](auto& arg) {
        catena::Value elemValue;
        toProto(elemValue, &arg, subParam, authz);
        catena::StructVariantValue* structVariant = dst.mutable_struct_variant_value();
        structVariant->set_struct_variant_type(variantType);
        *structVariant->mutable_value() = elemValue;
    }, *src);
}

/**
 * Free standing method to deserialize a value from protobuf
 * 
 * generic template declaration
 * 
 * @tparam T the type of the value
 */
template <typename T>
void fromProto(const catena::Value& src, T* dst, const IParamDescriptor& pd, const Authorizer& authz);

/**
 * fromProto specialization to deserialize an entire array of structured data
 * from protobuf
 * 
 * enabled if T is a vector of struct with isCatenaStruct defined
 * 
 * @tparam T the type of the value
 */
template <CatenaStructArray T>
void fromProto(const catena::Value& src, T* dst, const IParamDescriptor& pd, const Authorizer& authz) {
    using structType = T::value_type;
    if (!src.has_struct_array_values()) {
        // src is not an array so it cannot be deserialized into an array
        return;
    }
    auto& srcArray = src.struct_array_values().struct_values();
    dst->clear(); // empty the destination vector
    
    // Right now from proto is able to append any number of values to the
    // vector
    // Do we want to keep this behavior?

    // iterate over each element in the src array and call fromProto for each
    for (int i = 0; i < srcArray.size(); ++i) {
        catena::Value item;
        *item.mutable_struct_value() = srcArray.Get(i);
        structType& elemValue = dst->emplace_back();
        fromProto(item, &elemValue, pd, authz);
    }
}

/**
 * fromProto specialization to deserialize a single struct value from protobuf.
 * 
 * recursively calls fromProto for each field in the struct
 * 
 * enabled if T has isCatenaStruct defined
 * 
 * @tparam T the type of the value
 */
template <CatenaStruct T>
void fromProto(const catena::Value& src, T* dst, const IParamDescriptor& pd, const Authorizer& authz) {
    auto fields = StructInfo<T>::fields; // get tuple of FieldInfo for this struct type
    if (!src.has_struct_value()) {
        // src is not a struct so it cannot be deserialized into a struct
        return;
    }
    auto& srcFields = src.struct_value().fields();

    // lambda function to call fromProto for the given field if it is authorized
    auto writeField = [&](const auto& field) {
        IParamDescriptor& subParam = pd.getSubParam(field.name);
        if (!authz.writeAuthz(subParam)) {
            // not authorized to write to this field or the field is not in
            // the src
            return;
        }
        if (!srcFields.contains(field.name)) {
            // field not found in src so it is not being updated
            return;
        }
        const catena::Value& fieldValue = srcFields.at(field.name);

        /**
         * &(dst->*(field.memberPtr)) will pass the address of the
         * corresponding value field in dst to the fromProto function.
         * 
         * the correct specialization of fromProto will be called based on the
         * type of the field memberPtr.
         */
        fromProto(fieldValue, &(dst->*(field.memberPtr)), subParam, authz);
    };

    // call writeField for each field in the dst struct
    // If the src value contains a field that is not in the dst struct, it will
    // be ignored
    std::apply([&](auto... field) {
        (writeField(field), ...);
    }, fields);
}

template <IsVariantArray T>
void fromProto(const catena::Value& src, T* dst, const IParamDescriptor& pd, const Authorizer& authz) {
    using VariantType = T::value_type;
    if (!src.has_struct_variant_array_values()) {
        // src is not an array so it cannot be deserialized into an array
        return;
    }
    auto& srcArray = src.struct_variant_array_values().struct_variants();
    dst->clear(); // empty the destination vector

    // iterate over each element in the src array and call fromProto for each
    for (int i = 0; i < srcArray.size(); ++i) {
        catena::Value item;
        *item.mutable_struct_variant_value() = srcArray.Get(i);
        VariantType& elemValue = dst->emplace_back();
        fromProto(item, &elemValue, pd, authz);
    }
}

/**
 * @brief helper function to find the index of a type in a list of type names
 * @param typeName the name of the type to find
 * @param typeNames the list of type names to search
 * @return the index of the type in the list or the size of the list if the
 * type is not found
 */
template <std::size_t size>
inline std::size_t _findTypeIndex(const std::string& typeName, const std::array<const char*, size>& typeNames) {
    return std::find(typeNames.begin(), typeNames.end(), typeName) - typeNames.begin();
}

/**
 * @brief _changeType is a helper function to change the type held by a variant
 * @tparam V the type of the variant
 * @tparam Index the index of the current type being checked
 * @param variant the variant to change the type of
 * @param newTypeIndex the index of the new type to change to
 * 
 * This function is used by fromProto to change the type of a variant to the
 * type specified in the src protobuf message. It is a recursive function that
 * checks each type in the variant until it finds the type that matches the
 * newTypeIndex. If the type is not found, the variant is left unchanged. If
 * the type is found, the variant is changed to the default value of the new
 * type.
 */
template <meta::IsVariant V, std::size_t Index>
void _changeType(V& variant, const std::size_t newTypeIndex) {
    if constexpr (Index == std::variant_size_v<V>) {
        // reached the end of the variant, type not found
        return;
    } else {
        using NewType = std::variant_alternative_t<Index, V>;
        if (newTypeIndex == Index) {
            // found the new type, change the variant to the default value of
            // the new type
            variant = NewType{};
        } else {
            _changeType<V, Index + 1>(variant, newTypeIndex);
        }
    }
}

template <meta::IsVariant T>
void fromProto(const catena::Value& src, T* dst, const IParamDescriptor& pd, const Authorizer& authz) {
    if (!src.has_struct_variant_value()) {
        // src is not a variant so it cannot be deserialized into a variant
        return;
    }
    const catena::StructVariantValue& srcVariant = src.struct_variant_value();
    std::string variantType = srcVariant.struct_variant_type();
    
    std::size_t typeIndex = _findTypeIndex(variantType, alternativeNames<T>);
    if (typeIndex >= alternativeNames<T>.size()) {
        // variant type not found in the list of alternatives
        return;
    }
    if (typeIndex != dst->index()) {
        // The type of the variant needs to be changed
        _changeType<T, 0>(*dst, typeIndex);
    }

    IParamDescriptor& subParam= pd.getSubParam(variantType);
    std::visit([&](auto& arg) {
        fromProto(srcVariant.value(), &arg, subParam, authz);
    }, *dst); 
}

}  // namespace common
}  // namespace catena
